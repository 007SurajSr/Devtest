<!-- <script>
function fruit () {
    console.log(name);
    console.log(price);
    
     var name = "apple";     // Hoisting is applied in this
      let price = 20;        // in 'let' and 'const' hoisting is not applied ==> throws error.
}
fruit();
</script>  
 

 <script>
    for( var i=0; i<3; i++){                  // loop will completed first and i will get become 3 because 'var' is 'Global Scope' variable. 
        setTimeout(() => console.log(i),1 );  // after loop this timeFunction will run and will give three times 3 
    }
</script>  

 <script>
    for(let i=0; i<3; i++) {                 // 'let' is the 'Blocked Scope' variable so every setTimeOut there will be diffferent value of i
        setTimeout(() => console.log(i), 1);
    }
</script>  

 <script>
    console.warn( +true);        // + will convert the string in number / convert boolen value in corresponding number e.g- true=1, false=0; 
    console.warn(typeof +true);      // typeOf will give the Data type of assignment.
</script>  

 <Script>
    console.log(!"anil");        // Nuggation of strin value will give false.
    console.warn(typeof("anil")); // TypeOf of string value wil be string.
</Script>  

 <script>
    let data = "size";
    const  bird = {
        size : "small",
    };
    console.warn(bird[data]);   // Variable binding  
    console.warn(bird["size"]); // Data binding
    console.warn(bird.size);    // Key binging 
    console.warn(bird.data);    // Not any property... ==> undefined 
</script>  

 <script>
    let c = {name : "Peter"};  // 
    let d;                     // Both 'c' and 'd' have same memory reference and property. ==> it will get changed after new declaration.
    d = c;                     // when value of 'c' will change then value of 'd' wil get change as well.
    c.name = "anil";
    console.log(d.name);
</script>  

 <script>
    var x;          // 'var' is Global scope so it can be declared again and again. 
    var x = 10;     // 
    console.log(x);
</script>  

 <script>
    var x;
    let x = 10;     // 'let' is Blocked scope so we can not declare any same variable again with it.
    console.log(x);
</script>  

 <script>
    let a = 3;                  // 'a' is number in this
        let b = new Number(3);  // 'new Number' is the object

        console.log( a == b); // Value is same ==> true
        console.log( a === b); // Data Type is different ==> false
</script>  

 <script>
    let name;
    nmea = {};      // Typo difference therefore is will become different variable.
    console.log(name);  // undefined due to Hoisting.
</script>  

 <script>
    function fruit () {
        console.log("Woolf!");
    }
    fruit.name = "apple";
                                  // If we are making any extra Key outside the function then will not change anything in it.
    fruit();
    console.warn(fruit())
</script>  

 <script>
    function sum(a,b) {
        return a + b;      // They are getting concatinating here.
    }
    console.log(sum(1, "2"));   
</script>  

 <script>
    let number = 0;
    console.log(number++);  // variable 'number' is printed first and then increament done.
    console.log(++number);  // again increament is done and then number is increased by 2 here ==> so 2
    console.log(number);    // variable 'number' is already increased at 2 so result ==> 2
</script>  

 <script>
    function getAge(...args){
        console.log(typeof args);  // In JavaScript there is nothing array, there is only object.
    }
    getAge(21);
</script> 

<script>
    function getAge() {
        'use strict';     // while using 'use strict' we need to assign any 'var' or 'let' then we can use any variable.
        age = 21;
        console.log(age);
    }
    getAge();
</script>

 <script>
    const sum = eval('10*10+1'); // Perform any mathematical operation in its parameter.
    console.log(sum);
</script>

 <script>
    sessionStorage.setItem('Cool_secret', 123); // It will get removed one the tab is closed.
</script> 

<script>
    const obj = { 1 : "A", Hello : "a" , 2 : " b" , 3 : "c" };

    console.log(obj.hasOwnProperty("1"));    
    console.log(obj.hasOwnProperty(1));      
    
    console.log(obj.hasOwnProperty("Hello"));    
    console.log(obj.hasOwnProperty(Hello));      // if there is int value then we can check the property using 'string' and 'int'.      
</script> 

<script>
    const obj1 = { a: "one", b: "two" , a: "repeat"   };    // Property of 'a' has been overwrite and but position remain same.
    console.log(obj1); 
</script>
 
<script>
    for(let i=1; i<5; i++){
        if(i === 3) continue;    // Because at i=3 ==> if condition get failed and not running console.log9(i).
        console.log(i);
    }
</script> -->

<!-- <script>
    const foo = () => console.log('first');                     // Function declaration doesn't matter.  // Only function calling is matters.
    const bar = () => setTimeout(() => console.log('second'));  // We first execute our simple function first then we will come at SetTimeout function. 
    const baz = () => console.log('third');

    bar();
    foo();
    baz();
</script> -->

<!-- </script>         // most imprtant to put '/' while us
     <div> 
        <div onclick="console.log('first click')">
            <div onclick="console.log('second click')">
                <button onclick="console.log('click')">
                    Click!                               // This 'Click!' will make a bubbole, which will go bottom to top.
                </button>
            </div>
        </div>
        </div>
</script> -->


 <!-- <script>
    const person = { name : 'Lydia'};

    function sayHi(age) {
        return `${this.name} is ${age}`;
    }
    console.log(sayHi.call(person,21));  // It will call the functin as normal function
    console.log(sayHi.bind(person,21))   // This 'bind' functin need to call again then it will give result.
    console.log(sayHi.bind(person,21)())
 </script> -->

 <!-- <script>
    function sayHi() {
        return (() => 9)();  // In this immediately invoked function, this funcion will return -- 9.
    }
    console.log(typeof sayHi());    // TypeOf any digit is number. so result is --- number.
 </script> -->

 <!-- <script>
    function sayHi() {
        return () => 0;          // This return will give us only '() =>0 '
    }
    console.log(typeof sayHi()); // Result of this typeof will be -- function
</script> -->

<!-- <script>
    console.log(typeof typeof 1);  // First typeOf will give --' number' against '1'. Then next typeOf will give 'string' against 'number'
</script> -->

<!-- <script>
    const numbers = [1,2,3];
    numbers[6] = 11;          // We are putting value '11' at '6th' postion
    console.log(numbers);     // Postion which do not have values will be marked as expty. e.g- empty*times of vacant spaces. 
</script> -->

<!-- <script>
    const number = [1,2,3];
    number[7] = number;     // This will make an infinite loop. At every 7th index same array will be placed again and so on. 
    console.log(number);
</script> -->

<script>
    // Question 29. Everything in Javascript is either a ...
    //A. Primitive or object  ----- Correct
    //B. Function or object
    //C. Trick question! only object.
    //D. Number or object
</script>

<!-- <script>
console.log(!!null);   //'null' null == negative value(0), == > !0 == true, ==> !true == false
console.log(!!"");     // "" == 0 (Because it is empty). ==> !0 == true, ==> !true == false 
 console.log(!!1);     // '1' == true, ==> !true == false, ==> !false == true
</script> -->

<!-- <script>
    console.warn(setInterval(() => console.log('Hi'), 1000 ));  
    console.warn(setInterval(() => console.log('Hi'), 1000 ));
    console.warn(setInterval(() => console.log('Hi'), 1000 ));  // Every time setInterval will give us unique value starting from 1.
</script> -->

<!-- <script>
    console.log([..."anil"]);  // 'Spread Operato' It will split our array or string into minimal parts.
</script> -->

<!-- <script>
    let data = 3 + 4 + '5'; // First two numbers will get add and next wil get concatinated.
    console.log(data);
</script> -->

<!-- <script>
    console.log(typeof 3 + 4 + '5');  //  If we have 'typeOf' function then it will operate before the numeric operations.
</script> -->

<!-- <script>
    console.log(typeof (3 + 4 + +'5'));
</script> -->

<!-- <script>
    console.log(typeof []); // [] == object in JavaScript
</script> -->

<!-- <script>
    console.log([]==[]);  // ==> Result is false because both of the array will have different memory locations.
</script> -->

<!-- <script>
    let data = [1,2,3].map(num => {
        if(typeof num === 'number') return;  // Empty 'return' will give us only 'undefined'.
        return num * 2;
    });
    console.warn(data);
</script> -->

<script>
    function getInfo(member) {
        member.name = 'Anil';
    } 
    const person = { name : 'Sarah'};   // this wil changed by reference and result will come as 'Anil'.
    getInfo(person);
    console.log(person);
</script>